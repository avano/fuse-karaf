= JDBC

Before going into technical details of Datasource configuration in OSGi runtime (like {f7}), let's review the common
mechanisms of Database connectivity in Javaâ„¢ platform.

== Connections

The most important _object_ used to perform data manipulation is an implementation of `java.sql.Connection` interface.
We don't have to remind how to use this object, but from the perspective of {f7} configuration, it's important to
learn how to _obtain_ it.

The libraries that contain the objects I'm going to describe are:

* PostgreSQL: `mvn:org.postgresql/postgresql/42.2.2`
* MariaDB: `mvn:org.mariadb.jdbc/mariadb-java-client/2.2.3`
* MySQL: `mvn:mysql/mysql-connector-java/5.1.46`
* Derby: `mvn:org.apache.derby/derbyclient/10.14.1.0` and `mvn:org.apache.derby/derby/10.14.1.0` (for embedded driver)

If we check existing implementation (contained in _driver JARs_) we can find:

* PostgreSQL: `org.postgresql.jdbc.PgConnection`
* MariaDB: `org.mariadb.jdbc.MariaDbConnection`
* MySQL: `com.mysql.jdbc.JDBC4Connection` (see also different `connect*()` methods of `com.mysql.jdbc.Driver`)
* Derby (networked): `org.apache.derby.client.net.NetConnection` (for `jdbc:derby:net:*` or `jdbc:derby://`)
* Derby (embedded): `org.apache.derby.impl.jdbc.EmbedConnection` (for `jdbc:derby:*` or `jdbc:default:connection`)

These implementations contain database-specific logic to perform DML, DDL and simple transaction management.

In theory it's possible to manually create these connection objects, but there are two different JDBC methods that
hide the details and give cleaner API:

* `java.sql.Driver.connect()` - the method used in standalone applications long time ago
* `javax.sql.DataSource.getConnection()` - the preferred method using _factory_ pattern (note that similar method is
 used to obtain JMS connections from JMS connection factory. More about this later.)

We won't cover _driver manager_ approach here. It's enough to state that this method is just tiny _layer_ above
plain constructor of given connection object.

Using _data sources_ is quite complex topic and we'll talk about this later in this chapter.

=== Other connection interfaces

In addition to `java.sql.Connection` (which effectively implements database-specific communication protocol),
there are two other specialized _connection_ interfaces:

* `javax.sql.PooledConnection` which _represents_ physical connection while users's code doesn't interact with this
pooled connection directly. Instead the connection obtained using `getConnection()` method is used. This indirection
enables management of connection pool at the level of application server. The connection obtained using `getConnection()`
is usually a proxy. When such proxy connection is closed, physical connection is not closed and instead it becomes
available again in the managed connection pool.

* `javax.sql.XAConnection` allows obtaining `javax.transaction.xa.XAResource` associated with XA-aware connection
for use with `javax.transaction.TransactionManager`. Because `javax.sql.XAConnection` extends `javax.sql.PooledConnection,
it also provides method `getConnection()` giving access to JDBC connection object with typical DML/DQL methods.

== JDBC Data sources

JDBC 1.4 standard introduced `javax.sql.DataSource` interface that acted as _factory_ for `java.sql.Connection`
objects. Usually such data sources where bound to JNDI registry and located inside or injected into Java EE
components like servlets or EJBs. The key aspect was that these datasources were configured inside _application server_
and referenced in deployed applications by name.

Two remaining _connection_ objects have their own _data sources_:

|===
|data source |connection

|`javax.sql.DataSource`
|`java.sql.Connection`

|`javax.sql.ConnectionPoolDataSource`
|`javax.sql.PooledConnection`

|`javax.sql.XADataSource`
|`javax.sql.XAConnection`
|===

It's worth emphasizing the most important deferences between each of the above _data sources_:

* `javax.sql.DataSource` is most importantly a _factory_-like object to obtain `java.sql.Connection` instances.
The fact that most `javax.sql.DataSource` implementations usually perform _connection pooling_ should not
change the picture. This is the only interface that should be used by application code - whether it's direct JDBC
access, JPA persistence unit configuration (either `<jta-data-source>` or `<non-jta-data-source>`) or most of
the popular libraries (Apache Camel, Spring Framework, ...)
* `javax.sql.ConnectionPoolDataSource` is most importantly a _bridge_ between generic (non database-specific)
connection pool/data source and database-specific data source. It maybe be treated as SPI interface. Application
code usually deals with generic `javax.sql.DataSource` obtained from JNDI bound and implemented by application
server (probably using a library like commons-dbcp2). On the other end, application code doesn't deal with
`javax.sql.ConnectionPoolDataSource` directly - it's used between application server and database-specific driver.
This can be shown using this simple sequence diagram:
+
[plantuml]
....
Application -> "App Server": javax.sql.DataSource.getConnection()
"App Server" -[#0000FF]> "Database Driver": javax.sql.ConnectionPoolDataSource.getPooledConnection()
"Database Driver" -> "App Server": javax.sql.PooledConnection
"App Server" -> Application: javax.sql.PooledConnection.getConnection()
....

* `javax.sql.XADataSource` is a way to obtain `javax.sql.XAConnection` and `javax.transaction.xa.XAResource`. Same as
`javax.sql.ConnectionPoolDataSource`, it's used between application server and database-specific driver. Here's
slightly modified diagram with different actors, this time including JTA Transaction Manager:
+
[plantuml]
....
Application -> "App Server": UserTransaction.begin()
"App Server" -> "Transaction Manager": TransactionManager.getTransaction()
create Transaction
"Transaction Manager" -> Transaction: new
"App Server" <- Transaction: javax.transaction.Transaction

Application -> "App Server": DataSource.getConnection()
"App Server" -[#0000FF]> "Database Driver": XADataSource.getXAConnection()
create XAConnection
"Database Driver" -> XAConnection: new
XAConnection -> "App Server": javax.sql.XAConnection

"App Server" -> XAConnection: XAConnection.getXAResource()
XAConnection -> "App Server": javax.transaction.xa.XAResource
"App Server" -> Transaction: Transaction.enlistResource(XAResource)

"App Server" -> Application: XAConnection.getConnection()
....

As shown in two above diagrams, user interacts with _App Server_, which is generalized entity where we can configure
`javax.sql.DataSource` (and `javax.transaction.UserTransaction`) instance. Such instance may be
accessed either via JNDI or be injected using CDI or other DI mechanism.

IMPORTANT: The important thing is that even if we (the application) use XA transactions and/or connection pooling, we
(the application) interact with `javax.sql.DataSource` and not the two other JDBC data source interfaces.

=== Database specific and generic data sources

After the above introduction, we can separate JDBC data source implementations (of the three interfaces) into two
categories:

* generic `javax.sql.DataSource` implementations (like
http://commons.apache.org/proper/commons-dbcp/[Apache Commons DBCP(2)], Apache Tomcat JDBC (based on DBCP),
http://www.mchange.com/projects/c3p0/[C3P0], https://brettwooldridge.github.io/HikariCP[Hikari CP], ...)
* database specific implementations of `javax.sql.DataSource`, `javax.sql.XADataSource` and
`javax.sql.ConnectionPoolDataSource`

What probably creates some confusion is the fact that _generic_ `javax.sql.DataSource` implementation can't
create database-specific connections on its own. And even if such _generic_ data source may use `java.sql.Driver.connect()`
or `java.sql.DriverManager.getConnection()`, it's usually better/cleaner to configure this _generic_
data source with ... database-specific `javax.sql.DataSource` implementation.

When _generic_ data source is going to interact with JTA, it *has to* be configured with database-specific implementation
of `javax.sql.XADataSource`.

To close the picture, _generic_ data source usually *doesn't* need database-specific implementation of
`javax.sql.ConnectionPoolDataSource` in order to perform connection pooling - existing pools usually handle pooling
without standard JDBC interfaces (`javax.sql.ConnectionPoolDataSource` and `javax.sql.PooledConnection`).
